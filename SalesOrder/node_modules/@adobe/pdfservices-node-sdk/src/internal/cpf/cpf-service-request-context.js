/*
 * Copyright 2019 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */

const CPFRequestKeys = require('./cpf-service-request-key'),
	_ = require('lodash-core'),
	DCDefaultConfig = require('./../config/dc-services-default-config'),
	HttpRequest = require('../http/http-request');


class CPFServiceRequestContext {
	constructor(clientConfig) {
		Object.defineProperty(this, 'clientConfig', {
			value: clientConfig,
			writable: false
		});

		this.baseOptions = null;

	}

	setOptionsMaps() {

		const baseOptions = new Map();

		// Common request options
		let cpfRequestOptions = {
			headers: {
				'Accept': 'application/json, text/plain, */*',
				'x-api-app-info': DCDefaultConfig.appInfo
			},
			authenticate: true
		};

		//Initialize CPF create template
		const cpfCreateRequestOptions = {};
		cpfCreateRequestOptions.requestConfig = {
			method: 'POST',
			uriTemplate: this.clientConfig.opsCreateUri,
			queryParams: {
				respondWith: '{"reltype": "http://ns.adobe.com/rel/primary"}'
			},
			connectTimeout: this.clientConfig.connectTimeout,
			readTimeout: this.clientConfig.readTimeout
		};
		cpfCreateRequestOptions.request_content_open = true;

		// Add default headers and any custom options.
		_.extend(cpfCreateRequestOptions, cpfRequestOptions);
		cpfCreateRequestOptions.headers.Prefer = 'respond-async,wait=0';
		baseOptions.set(CPFRequestKeys.CPF_CREATE, cpfCreateRequestOptions);

		// Initialize CPF Status template
		const cpfStatusRequestOptions = {};
		cpfStatusRequestOptions.requestConfig = {
			method: 'GET',
			connectTimeout: this.clientConfig.connectTimeout,
			readTimeout: this.clientConfig.readTimeout
		};
		cpfStatusRequestOptions.response_content_open = true;

		// Add default headers and any custom options.
		_.extend(cpfStatusRequestOptions, cpfRequestOptions);
		baseOptions.set(CPFRequestKeys.CPF_STATUS, cpfStatusRequestOptions);

		this.setBaseOptions(baseOptions);
	}

	setBaseOptions(baseOptions) {
		this.baseOptions = baseOptions;
	}

	getBaseHttpRequest(key) {
		if (this.baseOptions === null) {
			this.setOptionsMaps();
		}
		const baseOptions = this.baseOptions.get(key);
		return new HttpRequest(_.cloneDeep(baseOptions));
	}
}

module.exports = CPFServiceRequestContext;
