/*
 * Copyright 2019 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */

const inputTypes = require('./../io/input-types'),
	ExtensionMediaTypeMapping = require('./../extension-mediatype-mapping'),
	fs = require('fs'),
	FileRef = require('./../../io/file-ref'),
	PageRanges = require('./../../operation/option/page-ranges'),
	_ = require('lodash-core'),
	{
		ExtractRenditionsElementType, ExtractElementType, TableStructureType
	} = require('../../operation/option/extractpdf/extract-pdf-options');

const PASSWORD_MAX_LENGTH = 128,
	PAGE_RANGES_ARRAY_MAX_LENGTH = 100,
	REMOVE_PROTECTION_PASSWORD_MAX_LENGTH = 150,
	USER_STRING = "User",
	OWNER_STRING = "Owner",
	SPLIT_PDF_OUTPUT_COUNT_LIMIT =20;

function validateClientContext(context) {
	if (!context || !context.clientConfig) {
		throw new Error('Client Context not initialized before invoking the operation');
	}

	context.clientConfig.validate();
	context.validate();
}

function isStringType(string) {
	return typeof (string) === 'string' || string instanceof String;
}

function validateMediaType(mediaType) {
	if (!mediaType) {
		throw new Error('Source file mediatype must not be null');
	}
	if (!isStringType(mediaType)) {
		throw new TypeError('Source file mediatype should be string');
	}
	if (!(ExtensionMediaTypeMapping.getExtensionFromMediaType(mediaType))) {
		throw new Error(`${mediaType} media type is not allowed`);
	}
}

/* eslint default-case:0
no-case-declarations:0 */
function validateFileRef(sourceFileRef) {
	if (!sourceFileRef) {
		throw new Error('No input was set for operation');
	}
	if (!(sourceFileRef instanceof FileRef)) {
		throw new Error('Input should be a Fileref instance');
	}

	const fileInfo = sourceFileRef.input;

	switch (fileInfo.inputType) {
		case inputTypes.localFile:
			if (!fileInfo.fileSource) {
				throw new Error('Source file path must not be null');
			}
			if (!(typeof (fileInfo.fileSource) === 'string' || fileInfo.fileSource instanceof String)) {
				throw new TypeError('Source file path should be string');
			}
			if (!(fs.existsSync(fileInfo.fileSource))) {
				throw new Error(`no such file or directory, ${fileInfo.fileSource}`);
			}
			break;
		case inputTypes.stream:
			if (!fileInfo.fileSource) {
				throw new Error('Source inputStream must not be null');
			}
			break;
	}
	if (sourceFileRef.input._inputType === inputTypes.url) {
		return;
	}
	validateMediaType(fileInfo.mediaType);
}

function validateAllowedMediaType(allowedMediaTypes, sourceFileRef) {
	if (sourceFileRef.input._inputType === inputTypes.url) {
		return;
	}
	if (!allowedMediaTypes.includes(sourceFileRef.input.mediaType)) {
		throw new Error(`Operation cannot be performed on the specified input media type : ${
			sourceFileRef.input.mediaType}`);
	}
}

function validateOptionInstanceType(mediaTypeOptionClassMap, sourceFileRef, options) {
	if (sourceFileRef.input._inputType === inputTypes.url) {
		return;
	}
	const mediaType = sourceFileRef.input.mediaType,
		instanceType = mediaTypeOptionClassMap.get(ExtensionMediaTypeMapping.getFormatFromMediaType(mediaType));
	if (!instanceType || !(options instanceof instanceType)) {
		throw new Error(`Invalid option instance type provided for source media type ${mediaType}`);
	}
}

function validateOperationOptions(options) {
	const errors = options.validate();
	if (errors.length > 0) {
		const messages = [];
		errors.forEach(err => messages.push(err.message));
		throw new Error(messages.join('; '));
	}
}

function validatePageRanges(pageRanges) {
	if (!(pageRanges instanceof PageRanges)) {
		throw new Error('CombineOperation expects only PageRanges instance as 2nd argument for addInput');
	}
	if (!pageRanges) {
		throw new Error('No page options provided for combining files PDFs');
	}
	if (pageRanges._ranges.length > PAGE_RANGES_ARRAY_MAX_LENGTH) {
		throw new Error('Maximum allowed limit exceeded for page ranges');
	}
	pageRanges.validate();
}

function validateFileWithPageOptions(input, allowedMediaTypes) {
	validateFileRef(input.getSourceFileRef());
	validateAllowedMediaType(allowedMediaTypes, input.getSourceFileRef());
	validatePageRanges(input.getPageRanges());
}

function validatePassword(password, isUserPassword, encryptionAlgorithm) {

	if (password.length === 0) {
		throw new Error(`${isUserPassword ? `${USER_STRING}` : `${OWNER_STRING}`} Password cannot be empty`);
	}

	if (password.length > PASSWORD_MAX_LENGTH) {
		throw new Error(`${isUserPassword ? `${USER_STRING}` : `${OWNER_STRING}`} Password length cannot exceed ${PASSWORD_MAX_LENGTH} bytes`);
	}
	if (encryptionAlgorithm === 'AES_128' && !isLatin(password)) {
		throw new Error(`${isUserPassword ? `${USER_STRING}` : `${OWNER_STRING}`} Password supports only LATIN-I characters for AES-128 encryption`);
	}
}

function validateExtractRenditionsInput(renditionParam){
	if(![ExtractRenditionsElementType.FIGURES,ExtractRenditionsElementType.TABLES].includes(renditionParam)){
		throw new Error('Forbidden value passed in parameters for renditions');
	}
}

function validateExtractElementsInput(elementParam){
	if(![ExtractElementType.TEXT,ExtractElementType.TABLES].includes(elementParam)){
		throw new Error('Forbidden value  passed in params for elements to extract');
	}
}

function validatePageRangesForOperation(pageRanges) {
	if (!(pageRanges instanceof PageRanges)) {
		throw new Error('Operation expects only PageRanges instance');
	}
	if (!pageRanges || pageRanges._ranges.length === 0) {
		throw new Error('No page ranges were set for the operation');
	}
	if (pageRanges._ranges.length > PAGE_RANGES_ARRAY_MAX_LENGTH) {
		throw new Error('Maximum allowed limit exceeded for page ranges');
	}
	pageRanges.validate();
}

function validatePasswordToRemoveProtection(password) {
	if (!password || password.length === 0) {
		throw new Error('Password cannot be null or empty');
	}
	if (password.length > REMOVE_PROTECTION_PASSWORD_MAX_LENGTH) {
		throw new Error(`Allowed maximum length of password is ${REMOVE_PROTECTION_PASSWORD_MAX_LENGTH} characters`);
	}
}

// check whether the password given with AES_128 encryption algorithm is in LATIN-I encoding or not
function isLatin(password) {
	for (let character = 0; character < password.length; character++) {
		if (password.charCodeAt(character) > 255) {
			return false;
		}
	}
	return true;
}

function validateProtectPDFOptions(options) {

	// Validate encryption algo
	if (!options.encryptionAlgorithm) {
		throw new Error("Encryption algorithm cannot be null");
	}

	if (!options.userPassword && !options.ownerPassword) {
		throw new Error("One of the password (user/owner) is required");
	}

	// Validate user password
	if (options.userPassword)
		validatePassword(options.userPassword, true, options.encryptionAlgorithm);


	// Validate owner password
	if (options.ownerPassword)
		validatePassword(options.ownerPassword, false, options.encryptionAlgorithm);

	// User and owner password cannot have same value
	if(options.ownerPassword && options.userPassword && options.userPassword === options.ownerPassword){
		throw new Error('User and owner password can not be same');
	}
	// OwnerPassword is mandatory in case the permissions are provided
	if (options.permissions != null && options.permissions.size !== 0 && !options.ownerPassword)
		throw new Error("The document permissions cannot be applied without setting owner password");

}

function validateExtractPDFOptions(options) {

	if (options) {
		// Validate elements to extract not null
		if (!options.elementsToExtract) {
			throw new Error("Elements to extract cannot be null");
		}

		// Validate extract renditions
		if (options.renditionsToExtract)
			options.renditionsToExtract.forEach(validateExtractRenditionsInput)

		// Validate extract elements
		if (options.elementsToExtract) {
			options.elementsToExtract.forEach(validateExtractElementsInput)
		}

		// Validate table structure type
		if (options.tableOutputFormat && ![TableStructureType.CSV, TableStructureType.XLSX].includes(options.tableOutputFormat)) {
			throw new Error("Forbidden value passed in table structure output format");

		}
	}
}

function validatePageRangesOverlap(pageRanges) {
	// Creating a copy in case the pageRange order matters in the original pageRanges, as we will be sorting the range list.
	let pageRangeList = _.cloneDeep(pageRanges._ranges);

	pageRangeList.sort((a,b) =>{ return a.start - b.start })

	for(let i = 1; i < pageRangeList.length; i++) {
		if(!pageRangeList[i-1].getEnd() || pageRangeList[i].getStart() <= pageRangeList[i-1].getEnd()) {
			throw new Error("The overlapping page ranges are not allowed");
		}
	}
}

function validateSplitOptions(pageRanges, pageCount, fileCount){
	if (pageRanges == null && pageCount == null && fileCount == null) {
		throw new Error("One of the options(page ranges/file count/page count) is required for splitting a PDF document");
	}
	if (pageRanges != null) {
		if(pageCount != null || fileCount != null) {
			throw new Error("Only one of option (page ranges/page count/file count) can be specified for splitting a PDF document");
		}

		if (pageRanges._ranges.length > SPLIT_PDF_OUTPUT_COUNT_LIMIT) {
			throw new Error("Too many page ranges specified");
		}
		validatePageRangesOverlap(pageRanges);
		validatePageRangesForOperation(pageRanges);
		return;
	}
	if (pageCount != null) {
		if (fileCount != null) {
			throw new Error("Only one of option (page ranges/page count/file count) can be specified for splitting a PDF document");
		}
		if(typeof pageCount != 'number'){
			throw new Error("Page count should be a number");
		}
		if (pageCount <= 0) {
			throw new Error("Page count should be greater than 0");
		}

		return;
	}

	if(typeof fileCount != 'number'){
		throw new Error("File count should be a number");
	}

	if (fileCount <= 0) {
		throw new Error("File count should be greater than 0");
	}

	if (fileCount > SPLIT_PDF_OUTPUT_COUNT_LIMIT) {
		throw new Error(`Input PDF file cannot be split into more than ${SPLIT_PDF_OUTPUT_COUNT_LIMIT} documents`);
	}
}

module.exports = {
	validateClientContext,
	validateFileRef,
	validateAllowedMediaType,
	validateOptionInstanceType,
	validateOperationOptions,
	validateFileWithPageOptions,
	validateProtectPDFOptions,
	validatePageRangesForOperation,
	validatePasswordToRemoveProtection,
	validateSplitOptions,
	validateExtractPDFOptions
};
