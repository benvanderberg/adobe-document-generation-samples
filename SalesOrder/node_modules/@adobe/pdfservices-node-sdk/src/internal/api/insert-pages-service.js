/*
 * Copyright 2019 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */

const CpfOperationService = require('./cpf-operation-service'),
	cpfConfig = require('../config/cpf-engine-config.js'),
	CPFMessage = require('./../cpf/cpf-message'),
	PageRanges = require('./../../operation/option/page-ranges'),
	PageRange = require('../../internal/io/page-range'),
	CpfDocument = require('../cpf/request/platform/cpf-document.js');

class InsertPagesService extends CpfOperationService {
	constructor() {
		super();
	}

	compare(filesToInsertFirst,filesToInsertSec){

		const filesToInsertFirstIndex = filesToInsertFirst.index;
		const filesToInsertSecIndex = filesToInsertSec.index;

		let comparison = 0;
		if (filesToInsertFirstIndex > filesToInsertSecIndex) {
			comparison = 1;
		} else if (filesToInsertFirstIndex < filesToInsertSecIndex) {
			comparison = -1;
		}
		return comparison;
	}

	generateInputFilesList(sourceFileRefs){
		let inputFileList = [];
		for(let i = 0; i < sourceFileRefs.length; i++){
			let inputFile = new CpfDocument(sourceFileRefs[i].input.mediaType,'file'+`${i}`);
			inputFileList.push(inputFile);
		}
		return inputFileList;
	}

	generateDocumentsInList(sourceFileRefs, includeRanges){
		let documentsInList = [];
		for(let i = 0; i < sourceFileRefs.length; i++){
			let documentsIn = {};
			documentsIn.documentIn = new CpfDocument(sourceFileRefs[i].input.mediaType,'file'+`${i}`);
			documentsIn.pageRanges = {};
			includeRanges[i] = includeRanges[i].getRanges();
			documentsIn.pageRanges['cpf:inline'] = includeRanges[i].length !== 0 ? includeRanges[i] : [new PageRange(1, undefined)];
			documentsInList.push(documentsIn);
		}
		return documentsInList;
	}

    getFilestoInsert(baseFileRef, filesToInsert){
		let keys = Object.keys(filesToInsert);
		keys.sort();
		let fileRefList = [],
			pageRangeList = [];
		let baseFileStartIndex = 1;

		for (let key of keys) {
			let entry = parseInt(key,10);
			if (entry !== 1) {
				fileRefList.push(baseFileRef);
				let pageRange = new PageRanges();
				pageRange.addPageRange(baseFileStartIndex,entry-1);
				pageRangeList.push(pageRange);
				baseFileStartIndex = entry;
			}
			for (let combineOperationInput of filesToInsert[key]) {
				fileRefList.push(combineOperationInput.getSourceFileRef());
				pageRangeList.push(combineOperationInput.getPageRanges());
			}
		}
		fileRefList.push(baseFileRef);
		let pageRange = new PageRanges();
		pageRange.addAllFrom(baseFileStartIndex);
		pageRangeList.push(pageRange);
		return {fileRefList:fileRefList, pageRangeList: pageRangeList};
	}
	getCPFMessage(operationMessage) {
		let filesAndPageRanges = this.getFilestoInsert(operationMessage.baseFileRef,operationMessage.sourceFileRefs),
			fileRefList = filesAndPageRanges.fileRefList,
			pageRangeList = filesAndPageRanges.pageRangeList;
		if(fileRefList.length > 20){
			throw new Error("Too many insertions specified for the operation");
		}

		let outputDocument = new CpfDocument('application/pdf','file'),
			params = {},
			inputDocuments = this.generateDocumentsInList(fileRefList, pageRangeList),
			files = fileRefList;

		return new CPFMessage(inputDocuments, outputDocument, params, files, cpfConfig.combinePdf);
	}

}

module.exports = InsertPagesService;
