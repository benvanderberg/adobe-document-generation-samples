/*
 * Copyright 2019 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */

const logger = require('./../logger'),
	CPFApi = require('./cpf-api'),
	CpfEngine = require('../cpf/request/platform/cpf-engine.js'),
	CpfContentAnalyzerRequests = require('../cpf/request/platform/cpf-content-analyzer-requests.js'),
	DefaultConfig = require('../config/dc-services-default-config'),
	outputType = require('../io/output-types.js'),
	fs = require("fs");

/**
 * Operation Service is an abstract class. All the document operation services need to inherit this class and have to
 * override getCPFMessage. CPFApi class is used for making the CPF Predict and Status API calls.
 */
class CpfOperationService {

	constructor() {
		if (this.constructor === CpfOperationService) {
			throw new TypeError("Can not construct CpfOperationService class.");
		}
	}

	getCPFMessage(operationMessage) {
		throw new Error("Method 'getCPFMessage()' must be implemented.");
	}

	doesOperationSupportMultipleFileOutput(operationMessage) {
		if (operationMessage.operationName === DefaultConfig.operationName.splitPDF || operationMessage.operationName === DefaultConfig.operationName.exportPdfToImages) {
			return true;
		}
		return false;
	}

	perform(context, operationMessage) {
		let cpfMessage = this.getCPFMessage(operationMessage),
			engine = new CpfEngine(cpfMessage.cpfEngineConfig),
			contentAnalyzerRequests = new CpfContentAnalyzerRequests(engine,cpfMessage.inputDocuments,cpfMessage.params,cpfMessage.outputDocument, cpfMessage.extractOutputInfo,cpfMessage.inputUrl),
			contentAnalyzerRequestsJsonString = JSON.stringify(contentAnalyzerRequests);

		let operation = operationMessage.operationName.replace(/\s/g, '');
		return CPFApi.cpfCreateApi(context, cpfMessage.files, contentAnalyzerRequestsJsonString, operation)
			.then(location => {
				return CPFApi.cpfStatusApi(context, location, operationMessage.targetFileName ,cpfMessage.extractOutputInfo != null );})
			.then(targetFileRef => {
				// For single output in Split PDF operation
				if(!Array.isArray(targetFileRef) && this.doesOperationSupportMultipleFileOutput(operationMessage)){
					targetFileRef.input.isOperationResult = true;
					targetFileRef = [targetFileRef];
				}
				else if(!Array.isArray(targetFileRef)){
					targetFileRef.input.isOperationResult = true;
				}
				else{
					for(let i = 0; i < targetFileRef.length; i++){
						targetFileRef[i].input.isOperationResult = true;
					}
				}
				logger.info(operationMessage.operationName + ' successfully completed');
				if(operationMessage.outputType===outputType.jsonObject){
					const jsonData = JSON.parse(fs.readFileSync(targetFileRef.input._fileSource));
					return Promise.resolve(jsonData);
				}
				return Promise.resolve(targetFileRef);
			})
			.catch(res => Promise.reject(res));
	}

}

module.exports = CpfOperationService;
