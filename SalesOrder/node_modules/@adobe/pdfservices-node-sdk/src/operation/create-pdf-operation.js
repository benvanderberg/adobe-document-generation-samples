/*
 * Copyright 2019 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */

const CreatePDFService = require('../internal/api/create-pdf-service'),
	ExtensionMediaTypeMapping = require('../internal/extension-mediatype-mapping'),
	OperationMessage = require('../internal/cpf/operation-message'),
	{ getRandomFileNameWithExtension } = require('../internal/util/path-util'),
	logger = require('./../internal/logger'),
	CreatePDFFromHtmlOptions = require('./option/createpdf/create-pdf-from-html-options'),
	CreatePDFFromWordOptions = require('./option/createpdf/create-pdf-from-word-options'),
	CreatePDFFromExcelOptions = require('./option/createpdf/create-pdf-from-excel-options'),
	CreatePDFFromPPTOptions = require('./option/createpdf/create-pdf-from-ppt-options'),
	DefaultConfig =  require('../internal/config/dc-services-default-config.js'),
	{
		validateClientContext, validateFileRef, validateAllowedMediaType,
		validateOptionInstanceType, validateOperationOptions
	} = require('./../internal/util/validation-util'),
	_ = require('lodash-core');


/**
 *
 * Supported source file formats for {@link CreatePDFOperation}.
 * @deprecated Since version 1.1.0; Use SupportedSourceFormat instead.
 * @enum
 * @readonly
 * @memberOf CreatePDFOperation
 *
 */
const SupportedMediaTypes = {

		/**
         * Represents "image/bmp" media type
         * @type {string}
         */
		bmp: ExtensionMediaTypeMapping.bmp.mediaType,

		/**
         * Represents "application/msword" media type
         * @type {string}
         */
		doc: ExtensionMediaTypeMapping.doc.mediaType,

		/**
         * Represents "application/vnd.openxmlformats-officedocument.wordprocessingml.document" media type
         * @type {string}
         */
		docx: ExtensionMediaTypeMapping.docx.mediaType,

		/**
         * Represents "image/gif" media type
         * @type {string}
         */
		gif: ExtensionMediaTypeMapping.gif.mediaType,

		/**
	 	* Represents "text/html" media type
	 	* @type {string}
	 	*/
		html: ExtensionMediaTypeMapping.html.mediaType,

		/**
         * Represents "image/jpeg" media type
         * @type {string}
         */
		jpeg: ExtensionMediaTypeMapping.jpeg.mediaType,

		/**
         * Represents "image/jpeg" media type
         * @type {string}
         */
		jpg: ExtensionMediaTypeMapping.jpg.mediaType,

		/**
         * Represents "image/png" media type
         * @type {string}
         */
		png: ExtensionMediaTypeMapping.png.mediaType,

		/**
         * Represents "application/vnd.ms-powerpoint" media type
         * @type {string}
         */
		ppt: ExtensionMediaTypeMapping.ppt.mediaType,

		/**
         * Represents "application/vnd.openxmlformats-officedocument.presentationml.presentation" media type
         * @type {string}
         */
		pptx: ExtensionMediaTypeMapping.pptx.mediaType,

		/**
         * Represents "text/rtf" media type
         * @type {string}
         */
		rtf: ExtensionMediaTypeMapping.rtf.mediaType,

		/**
         * Represents "image/tiff" media type
         * @type {string}
         */
		tif: ExtensionMediaTypeMapping.tif.mediaType,

		/**
         * Represents "image/tiff" media type
         * @type {string}
         */
		tiff: ExtensionMediaTypeMapping.tiff.mediaType,

		/**
         * Represents "text/plain" media type
         * @type {string}
         */
		txt: ExtensionMediaTypeMapping.txt.mediaType,

		/**
         * Represents "application/vnd.ms-excel" media type
         * @type {string}
         */
		xls: ExtensionMediaTypeMapping.xls.mediaType,

		/**
         * Represents "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" media type
         * @type {string}
         */
		xlsx: ExtensionMediaTypeMapping.xlsx.mediaType,

		/**
         * Represents "application/zip" media type
         * @type {string}
         */
		zip: ExtensionMediaTypeMapping.zip.mediaType
	};

Object.freeze(SupportedMediaTypes);

	/**
	 *
	 * Supported source file formats for {@link CreatePDFOperation}.
	 * @enum
	 * @readonly
	 * @memberOf CreatePDFOperation
	 *
	 */
const SupportedSourceFormat = {

		/**
		 * Represents "image/bmp" media type
		 * @type {string}
		 */
		bmp: ExtensionMediaTypeMapping.bmp.mediaType,

		/**
		 * Represents "application/msword" media type
		 * @type {string}
		 */
		doc: ExtensionMediaTypeMapping.doc.mediaType,

		/**
		 * Represents "application/vnd.openxmlformats-officedocument.wordprocessingml.document" media type
		 * @type {string}
		 */
		docx: ExtensionMediaTypeMapping.docx.mediaType,

		/**
		 * Represents "image/gif" media type
		 * @type {string}
		 */
		gif: ExtensionMediaTypeMapping.gif.mediaType,

		/**
		 * Represents "text/html" media type
		 * @type {string}
		 */
		html: ExtensionMediaTypeMapping.html.mediaType,

		/**
		 * Represents "image/jpeg" media type
		 * @type {string}
		 */
		jpeg: ExtensionMediaTypeMapping.jpeg.mediaType,

		/**
		 * Represents "image/jpeg" media type
		 * @type {string}
		 */
		jpg: ExtensionMediaTypeMapping.jpg.mediaType,

		/**
		 * Represents "image/png" media type
		 * @type {string}
		 */
		png: ExtensionMediaTypeMapping.png.mediaType,

		/**
		 * Represents "application/vnd.ms-powerpoint" media type
		 * @type {string}
		 */
		ppt: ExtensionMediaTypeMapping.ppt.mediaType,

		/**
		 * Represents "application/vnd.openxmlformats-officedocument.presentationml.presentation" media type
		 * @type {string}
		 */
		pptx: ExtensionMediaTypeMapping.pptx.mediaType,

		/**
		 * Represents "text/rtf" media type
		 * @type {string}
		 */
		rtf: ExtensionMediaTypeMapping.rtf.mediaType,

		/**
		 * Represents "image/tiff" media type
		 * @type {string}
		 */
		tif: ExtensionMediaTypeMapping.tif.mediaType,

		/**
		 * Represents "image/tiff" media type
		 * @type {string}
		 */
		tiff: ExtensionMediaTypeMapping.tiff.mediaType,

		/**
		 * Represents "text/plain" media type
		 * @type {string}
		 */
		txt: ExtensionMediaTypeMapping.txt.mediaType,

		/**
		 * Represents "application/vnd.ms-excel" media type
		 * @type {string}
		 */
		xls: ExtensionMediaTypeMapping.xls.mediaType,

		/**
		 * Represents "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" media type
		 * @type {string}
		 */
		xlsx: ExtensionMediaTypeMapping.xlsx.mediaType,

		/**
		 * Represents "application/zip" media type
		 * @type {string}
		 */
		zip: ExtensionMediaTypeMapping.zip.mediaType
	},
	allowedConfiguration = {

		getSupportedMediaTypes() {
			return Object.values(SupportedSourceFormat);
		},

		targetFileExtension: ExtensionMediaTypeMapping.pdf.extension,

		optionInstanceMapping: new Map([
			[ExtensionMediaTypeMapping.zip, CreatePDFFromHtmlOptions],
			[ExtensionMediaTypeMapping.html, CreatePDFFromHtmlOptions],
			[ExtensionMediaTypeMapping.doc, CreatePDFFromWordOptions],
			[ExtensionMediaTypeMapping.docx, CreatePDFFromWordOptions],
			[ExtensionMediaTypeMapping.rtf, CreatePDFFromWordOptions],
			[ExtensionMediaTypeMapping.txt, CreatePDFFromWordOptions],
			[ExtensionMediaTypeMapping.xls, CreatePDFFromExcelOptions],
			[ExtensionMediaTypeMapping.xlsx, CreatePDFFromExcelOptions],
			[ExtensionMediaTypeMapping.ppt, CreatePDFFromPPTOptions],
			[ExtensionMediaTypeMapping.pptx, CreatePDFFromPPTOptions],
		])

	};

Object.freeze(allowedConfiguration);
Object.freeze(SupportedSourceFormat);

/**
 * An operation that converts a non-PDF file to a PDF file. Some source formats may have associated conversion parameters
 * which can be set in the {@link CreatePDFOperation#setOptions} method.
 * <p>
 * The supported source media types are listed here. The {@link SupportedSourceFormat} object can be used to map file
 * extensions to their corresponding media types when creating FileRef instances for the source files.
 * <ul>
 * <li>application/msword</li>
 * <li>application/vnd.ms-excel</li>
 * <li>application/vnd.ms-powerpoint</li>
 * <li>application/vnd.openxmlformats-officedocument.presentationml.presentation</li>
 * <li>application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</li>
 * <li>application/vnd.openxmlformats-officedocument.wordprocessingml.document</li>
 * <li>application/zip (see "Special handling for HTML inputs" below) </li>
 * <li>image/bmp</li>
 * <li>image/gif</li>
 * <li>image/jpeg</li>
 * <li>image/png</li>
 * <li>image/tiff</li>
 * <li>text/html</li>
 * <li>text/plain</li>
 * <li>text/rtf</li>
 * </ul>
 *
 * <p>
 * <b>Special handling for HTML inputs:</b>
 * <p>
 * An HTML input can be provided either as a local zip archive or as a static HTML file with inline CSS. Alternatively, an HTML can also be specified via URL using {@link FileRef.createFromURL}.
 * <br>
 * While creating the corresponding FileRef instance, the media type must be:
 * <ul>
 * <li>"application/zip", if the input is a local zip archive.</li>
 * <li>"text/html", if the input is a static HTML file with inline CSS</li>
 * </ul>
 * <br>
 * In case the input is a local zip archive, it must have the following structure:
 * <ul>
 *
 * Sample layout:<br>
 *  <pre>
 *  &nbsp html_files.zip
 *  &nbsp |__index.html
 *  &nbsp |__referenced_file_1.css
 *  &nbsp |__referenced_file_2.jpeg
 *  &nbsp |__subfolder_1
 *  &nbsp |_____referenced_file_3.jpeg
 *  </pre>
 *
 * Sample Usage:
 * <pre class="prettyprint">
 * <code>
 *  const credentials = PDFServicesSdk.Credentials.serviceAccountCredentialsBuilder()
 *            .fromFile("pdfservices-api-credentials.json")
 *            .build(),
 *        executionContext = PDFServicesSdk.ExecutionContext.create(credentials),
 *        CreatePDF = PDFServicesSdk.CreatePDF,
 *        createPDFOperation = CreatePDF.Operation.createNew(),
 *        input = PDFServicesSdk.FileRef.createFromLocalFile('test/resources/createPDFInput.docx', CreatePDF.SupportedSourceFormat.docx);
 *
 *  createPDFOperation.setInput(input);
 *
 *  createPDFOperation.execute(executionContext)
 *      .then(result => result.saveAsFile('output/createPDF.pdf'))
 *      .catch(err => console.log(err));
 * </code>
 * </pre>
 *
 */
class CreatePDFOperation {
	/**
     * @hideconstructor
     */
	constructor() {
		this.sourceFileRef = null;
		this.options = null;
		Object.preventExtensions(this);
	}

	/**
     * Constructs a CreatePDFOperation instance.
     * @returns {CreatePDFOperation} A new CreatePDFOperation instance.
     *
     */
	static createNew() {
		return new CreatePDFOperation();
	}

	static get SupportedMediaTypes() {
		return SupportedMediaTypes;
	}

	static get SupportedSourceFormat() {
		return SupportedSourceFormat;
	}

	/**
     * Sets an input file.
     *
     * @param {!FileRef} sourceFileRef - An input file.
     */
	setInput(sourceFileRef) {
		this.sourceFileRef = sourceFileRef;
	}

	/**
     * Sets the conversion parameters for this operation.
     * @param {Object} options - Conversion parameters; use null for default values. The type of this parameter depends
     * on the source format of the file which is being converted to PDF. For example, for HTML to PDF conversions,
     * the type will be {@link CreatePDFFromHtmlOptions}. For other supported options, refer the <code>options</code> key.
     * in {@link module:PDFServicesSDK#CreatePDF}.
     */
	setOptions(options) {
		this.options = options;
	}

	/**
     * Executes this operation using the supplied context and returns a Promise which resolves to the operation result.
     *
     * The resulting file may be stored in the system temporary directory (per the os.tempdir(), symlinks are resolved
     * to the actual path).
     * See {@link FileRef} for how temporary resources are cleaned up.
     *
     * @param {!ExecutionContext} context - The context in which the operation will be executed.
     * @returns {Promise<FileRef>} A promise which resolves to the operation result.
     * @throws {ServiceApiError} if an API call results in an error response.
	 * @throws {ServiceUsageError} if service usage limits have been reached or credentials quota has been exhausted.
     */
	execute(context) {
		try {
			this.validate(context);
		} catch (err) {
			return Promise.reject(err);
		}
		logger.info('All validations successfully done. Beginning PDF conversion');
		const targetFileName = getRandomFileNameWithExtension(allowedConfiguration.targetFileExtension),
			operationMessage = new OperationMessage(this.sourceFileRef, targetFileName, DefaultConfig.operationName.createPdf),
			createPDFService = new CreatePDFService();
		operationMessage.setOptions(this.options);
		return createPDFService.perform(context, operationMessage)
			.then(res => Promise.resolve(res))
			.catch(err => Promise.reject(err));
	}

	validate(context) {
		validateClientContext(context);
		validateFileRef(this.sourceFileRef);
		validateAllowedMediaType(allowedConfiguration.getSupportedMediaTypes(), this.sourceFileRef);

		if (this.options != null) {
			validateOptionInstanceType(allowedConfiguration.optionInstanceMapping, this.sourceFileRef, this.options);
			const copy = _.cloneDeep(this.options);
			delete copy ['dataToMerge'];
			//To-do add validation for Options for HTML to PDF conversion
			validateOperationOptions(copy);

		}
	}
}

Object.freeze(CreatePDFOperation);
module.exports = CreatePDFOperation;
