/*
 * Copyright 2019 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */


const ExtractPDFService = require('../internal/api/extract-pdf-service'),
	OperationMessage = require('../internal/cpf/operation-message'),
	ExtensionMediaTypeMapping = require('../internal/extension-mediatype-mapping'),
	ExtractPDFOptions = require('./option/extractpdf/extract-pdf-options'),
	{getRandomFileNameWithExtension} = require('../internal/util/path-util'),
	logger = require('./../internal/logger'),
	DefaultConfig = require('../internal/config/dc-services-default-config.js'),
	{
		validateFileRef, validateAllowedMediaType,
		validateOptionInstanceType, validateExtractPDFOptions, validateOperationOptions
	} = require('./../internal/util/validation-util');


/**
 *
 * Supported source file formats for {@link ExtractPdfOperation} is .pdf.
 * @enum
 * @readonly
 * @memberOf ExtractPdfOperation
 *
 */
const SupportedSourceFormat = {

		/**
		 * Represents "application/pdf" media type
		 * @type {string}
		 */
		pdf: ExtensionMediaTypeMapping.pdf.mediaType
	},
	allowedConfiguration = {

		targetFileExtension: ExtensionMediaTypeMapping.zip.extension,

		getSupportedMediaTypes() {
			return Object.values(SupportedSourceFormat);
		}
	};
Object.freeze(allowedConfiguration);
Object.freeze(SupportedSourceFormat);

/**
 * An Operation that extracts pdf elements such as text, images, tables in a structured format from a PDF.
 *
 * Sample Usage:
 * <pre class="prettyprint">
 * <code>
 *  try {
 *	const credentials =  PDFServicesSdk.Credentials
 *		.serviceAccountCredentialsBuilder()
 * 		.fromFile("pdfservices-api-credentials.json")
 *		.build();
 *
 *	const clientConfig = PDFServicesSdk.ClientConfig
 *		.clientConfigBuilder()
 *		.fromFile("pdfservices-api-client-config.json")
 *		.build();
 *
 *	const clientContext = PDFServicesSdk.ExecutionContext
 *		.create(credentials,clientConfig);
 *
 *	const options = new PDFServicesSdk.ExtractPDF.options.ExtractPdfOptions.Builder()
 *		.addElementsToExtract(PDFServicesSdk.ExtractPDF.options.ExtractElementType.TEXT)
 *		.addElementsToExtractRenditions(PDFServicesSdk.ExtractPDF.options.ExtractRenditionsElementType.TABLES)
 *		.addCharInfo(true)
 *		.addTableStructureFormat(PDFServicesSdk.ExtractPDF.options.TableStructureType.CSV)
 *		.build();
 *
 *	const extractPDFOperation = PDFServicesSdk.ExtractPDF.Operation.createNew(),
 *		input = PDFServicesSdk.FileRef.createFromLocalFile(
 *			'test/resources/extractPDFInput',
 *			PDFServicesSdk.ExtractPDF.SupportedSourceFormat.pdf
 *		);
 *
 *	extractPDFOperation.setInput(input);
 * 	extractPDFOperation.setOptions(input);
 *
 *	extractPDFOperation.execute(clientContext)
 *		.then(result => result.saveAsFile('output/extractPdf.zip'))
 *		.catch(err => console.log(err));
 *   } catch (err) {
 *	throw err;
 *  }
 * </code>
 * </pre>
 *
 */
class ExtractPdfOperation {
	/**
	 * @hideconstructor
	 */
	constructor() {
		this.sourceFileRef = null;
		this.isInvoked = false;
		this.options = null;
		Object.preventExtensions(this);

	}

	/**
	 * Constructs a {@link ExtractPdfOperation} instance.
	 * @returns {ExtractPdfOperation} A new ExtractPdfOperation instance.
	 */
	static createNew() {
		return new ExtractPdfOperation();
	}

	static get SupportedSourceFormat() {
		return SupportedSourceFormat;
	}

	/**
	 * Sets an input file.
	 * @param {!FileRef} sourceFileRef - An input file.
	 */
	setInput(sourceFileRef) {
		this.sourceFileRef = sourceFileRef;
	}

	/**
	 * Sets the options for Extract PDF operation
	 * @param {!ExtractPDFOptions} options - Options specifying the Parameters for extract PDF
	 */
	setOptions(options) {
		this.options = options;
	}

	/**
	 * Executes this operation using the supplied context and returns a Promise which resolves to the operation result.
	 *
	 * The resulting file may be stored in the system temporary directory (per the os.tempdir(), symlinks are resolved
	 * to the actual path).
	 * See {@link FileRef} for how temporary resources are cleaned up.
	 *
	 * @param {!ExecutionContext} context - The context in which the operation will be executed.
	 * @returns {Promise<T>} A promise which resolves to the operation result.
	 * @throws {ServiceApiError} if an API call results in an error response.
	 * @throws {ServiceUsageError} if service usage limits have been reached or credentials quota has been exhausted.
	 */

	execute(context) {
		try {
			this.validate();
		} catch (err) {
			return Promise.reject(err);
		}
		logger.info('All validations successfully done. Beginning Extract Pdf operation execution');
		const targetFileName = getRandomFileNameWithExtension(allowedConfiguration.targetFileExtension),
			operationMessage = new OperationMessage(this.sourceFileRef, targetFileName, DefaultConfig.operationName.extractPdf),
			extractPDFService = new ExtractPDFService();
		this.isInvoked = true;
		operationMessage.setOptions(this.options);
		return extractPDFService.perform(context, operationMessage)
			.then(res => Promise.resolve(res))
			.catch(err => Promise.reject(err));
	}


	validate() {
		if (this.isInvoked)
			throw new Error('Operation instance must only be invoked once');
		validateFileRef(this.sourceFileRef);
		validateAllowedMediaType(allowedConfiguration.getSupportedMediaTypes(), this.sourceFileRef);
		validateExtractPDFOptions(this.options);

	}

}

Object.freeze(ExtractPdfOperation);
module.exports = ExtractPdfOperation;


